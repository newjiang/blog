# 1.背景

在单机时代，所有的代码，功能都是在一个应用程序里的。如果要实现一个锁的功能，那么只需要一个全局变量即可作为锁的资源。随着时代发现，单机系统越来越无法承受业务扩展所带来的负担，随后进入了微服务的时代了。相比于单机系统，微服务除了解决了业务扩展的问题，随之带来还有更复杂的问题，其中锁的问题就是其一。

刚刚说了单机系统只需要一个全局变量作为锁资源，可是在微服务里，这个系统里的全局变量变得不再“全局”和“唯一”了。如果一个系统模块有N个节点，每个节点可以有各自的全局变量，作为锁资源，但是它们却无法锁住其他节点，只能锁住自己的。显然，这个是不符合业务要求的，也是不能接受的。

# 2.分布式锁的特性
既然有问题，那么就解决问题吧。导致锁失效的原因，其实就是锁资源由原本全局，唯一被拆分了，导致无法锁住的。那么要在微服务中实现分布式锁，就需要一个全局的变量来为唯一的锁资源给到各个节点，当某一个节点拿到了锁资源的时候，其他节点是不能获取到该锁资源的。同时，释放锁资源也是应该由获锁资源的对象来释放。与单机不同的是，分布式锁在微服务中有新的问题，那就是当获取锁资源的对象突然挂了，此时的锁还没有来得及释放，其他的节点却永远获取不到锁的，也就是出现了“死锁”现象，这一点也是不接受。基于上述的问题，提出分布式锁必须以下特性：
- **互拆性**：仅有一个对象获取锁资源
- **避免死锁**：获取锁资源的对象出错了，能够释放锁资源
- **上锁/解锁同一个对象完成**：谁拿到了锁资源，就谁才能释放锁资源，上帝也不允许。

现在实现分布式锁的主流方案有两种，分别是基于**Redis**和**Zookeeper**实现的分布所锁。两者的实现还是有很大的不同的，个人比较倾向实现Zookeeper的分布式锁，但是也要具体情况具体分析。下面分别对Redis和Zookeeper是怎么实现分布式锁的进行讲解吧。